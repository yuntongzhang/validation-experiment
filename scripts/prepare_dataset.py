"""
python3 scripts/prepare_dataset.py --meta scripts/meta-data.json --patch-dst patches --input-dst inputs --src /home/yuntong/fuzzrepair-results-sep-05-original-repetition/
"""


import os
import argparse
import json
import random
import shutil
from os.path import join as pjoin
from tqdm import tqdm

NUM_PATCHES = 500
NUM_INPUTS = 10


def translate_patch_file():
    """
    Translate a patch file in fuzzrepair format, into po
    """

def collect_patches(dir: str, bug_id: str, num_required: int):
    """
    Collect patches from a dir.
    dir is the result directory generated by cerberus + fuzzrepair.
    """
    patch_dir = pjoin(dir, "output", bug_id, "enumerated-patches")
    if not os.path.isdir(patch_dir):
        return []
    patch_files = os.listdir(patch_dir)
    patch_files = [pjoin(patch_dir, f) for f in patch_files]
    # now select patches randomly
    res = random.sample(patch_files, min(num_required, len(patch_files)))
    return res


def collect_inputs(dir: str, bug_id: str, num_required: int):
    """
    Collect crashing inputs from a dir.
    dir is the result directory generarated by cerberus + fuzzrepair.
    """
    input_dir = pjoin(dir, "output", bug_id, "interested-crashing")
    if not os.path.isdir(input_dir):
        return []
    input_files = os.listdir(input_dir)
    input_files = [pjoin(input_dir, f) for f in input_files]
    # now select inputs randomly
    res = random.sample(input_files, min(num_required, len(input_files)))
    return res


def collect_exploit(dir: str, bug_id: str):
    """
    Collect the exploit input from the result dir.
    """
    out_dir = pjoin(dir, "output", bug_id)
    if not os.path.isdir(out_dir):
        return None
    files_and_dirs = os.listdir(out_dir)
    exploit = [f for f in files_and_dirs if f.endswith(".bup")]
    exploit = [pjoin(out_dir, f) for f in exploit]
    assert len(exploit) == 1
    return exploit[0]


def main():
    # make the selection more deterministic?
    random.seed(42)

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--src", required=True, help="Source where the patches should be pulled from."
    )
    parser.add_argument(
        "--patch-dst",
        required=True,
        help="Destination where the patches should be copied to.",
    )
    parser.add_argument(
        "--input-dst",
        required=True,
        help="Destination where the inputs should be copied to.",
    )
    parser.add_argument("--meta", required=True, help="Path to the meta file.")
    args = parser.parse_args()
    src_dir = args.src
    patch_dst_dir = args.patch_dst
    input_dst_dir = args.input_dst
    meta_file = args.meta

    if os.path.isdir(patch_dst_dir):
        shutil.rmtree(patch_dst_dir)
    if os.path.isdir(input_dst_dir):
        shutil.rmtree(input_dst_dir)
    os.makedirs(patch_dst_dir, exist_ok=True)
    os.makedirs(input_dst_dir, exist_ok=True)

    # collect the result directory names, from which we collect patches
    src_dirs = [pjoin(src_dir, d) for d in os.listdir(src_dir)]
    src_dirs = [d for d in src_dirs if os.path.isdir(d)]

    with open(meta_file, "r") as f:
        meta_data = json.load(f)

    bug_id_to_dirs = dict()

    for meta_entry in meta_data:
        id = int(meta_entry["id"])
        if id in [9, 10]:  # two bugs that could not be reproduced
            continue
        bug_id = meta_entry["bug_id"]
        subject = meta_entry["subject"]
        # find the output directories for this bug
        filtered_src_dirs = [d for d in src_dirs if bug_id in d]
        filtered_src_dirs = sorted(filtered_src_dirs)
        bug_id_to_dirs[bug_id] = filtered_src_dirs

    # collect patches
    print("Collecting patches...")
    for bug_id, dirs in tqdm(bug_id_to_dirs.items()):
        indivi_patch_dst_dir = pjoin(patch_dst_dir, bug_id)
        os.makedirs(indivi_patch_dst_dir, exist_ok=True)
        collected_patches = []
        for dir in dirs:
            num_required = NUM_PATCHES - len(collected_patches)
            if num_required <= 0:
                break
            collected_this_dir = collect_patches(dir, bug_id, num_required)
            collected_patches.extend(collected_this_dir)
        # copy collected patches to destination folder
        raw_patch_dest = pjoin(indivi_patch_dst_dir, "fuzzrepair_patches")
        os.makedirs(raw_patch_dest, exist_ok=True)
        num_copied = 0  # counter to set dest file names
        for patch_path in collected_patches:
            num_copied += 1
            dest_patch_path = pjoin(raw_patch_dest, f"patch_{num_copied}")
            shutil.copy(patch_path, dest_patch_path)

    # collect inputs
    print("Collecting inputs...")
    for bug_id, dirs in tqdm(bug_id_to_dirs.items()):
        indivi_input_dst_dir = pjoin(input_dst_dir, bug_id)
        os.makedirs(indivi_input_dst_dir, exist_ok=True)
        # (1) collect the single exploit file and put it somewhere
        one_dir = dirs[0]
        exploit_dst = pjoin(indivi_input_dst_dir, "exploit")
        os.makedirs(exploit_dst, exist_ok=True)
        exploit_input_orig_path = collect_exploit(one_dir, bug_id)
        shutil.copy(exploit_input_orig_path, exploit_dst)
        # (2) collect other crashing inputs
        collected_inputs = []
        for dir in dirs:
            num_required = NUM_INPUTS - len(collected_inputs)
            if num_required <= 0:
                break
            collected_this_dir = collect_inputs(dir, bug_id, num_required)
            collected_inputs.extend(collected_this_dir)
        # NOTE: in reality, there can be not enough inputs
        #       solution: duplicate the exploit input
        if len(collected_inputs) < NUM_INPUTS:
            num_required = NUM_INPUTS - len(collected_inputs)
            for _ in range(num_required):
                collected_inputs.append(exploit_input_orig_path)
        # (2.1) copy collected inputs to destination folder
        input_dst = pjoin(indivi_input_dst_dir, "others")
        os.makedirs(input_dst, exist_ok=True)
        num_copied = 0  # counter to set dest file names
        for input_path in collected_inputs:
            num_copied += 1
            dest_input_path = pjoin(input_dst, f"input_{num_copied}")
            shutil.copy(input_path, dest_input_path)

    # done with all bugs, let's check whether everything is ok
    for bug_id in bug_id_to_dirs:
        # check patches
        indivi_patch_dst_dir = pjoin(patch_dst_dir, bug_id)
        raw_patch_dest = pjoin(indivi_patch_dst_dir, "fuzzrepair_patches")
        if len(os.listdir(raw_patch_dest)) != NUM_PATCHES:
            print(f"Bug {bug_id} does not have enough patches.")
        # check inputs
        indivi_input_dst_dir = pjoin(input_dst_dir, bug_id)
        exploit_dst = pjoin(indivi_input_dst_dir, "exploit")
        if len(os.listdir(exploit_dst)) != 1:
            print(f"Bug {bug_id} does not have exactly one exploit input.")
        input_dst = pjoin(indivi_input_dst_dir, "others")
        if len(os.listdir(input_dst)) != NUM_INPUTS:
            print(f"Bug {bug_id} does not have enough inputs. Duplicating exploit input to make it e")
        
    print("Done.")


if __name__ == "__main__":
    main()
